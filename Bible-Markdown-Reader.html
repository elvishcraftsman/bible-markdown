<!DOCTYPE html>
<html>
<!--    This reader is a tool for converting Markdown to HTML that 
        serves as a prototype for how it can be done. The code
        may be freely copied and reused. -->

<head>
<title>Kingdom Study Bible</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="style.css">
<link href="https://fonts.googleapis.com/css2?family=Cardo:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

<script>

/* The following declarations are only for this reader/writer */
const defaultBible = `
Version: "Kingdom Study Bible (KSB)"
Publisher: None
Translator: Lynn Michael Martin
Copyright: CC0 or Public Domain
Description: A practice translation that I hope becomes more than that.

# Romans (ROM)

1:1 Paul, a servant of Jesus Christ, appointed an apostle, set apart to [the] gospel of God, 2 which he promised before, through his prophets in [the] holy writings, 3 about his Son, who was born from the offspring of David according to [the] flesh, 4 who was designated Son of God in power according to [the] Spirit of holiness, by [the] resurrection from the dead, Jesus Christ our Lord, 5 through whom we received favor and apostleship {for} obedience of faith in all the nations, on behalf of his name; 6 in whom you are also appointed by Jesus Christ; 7 to all [those] who are in Rome in [the] love of God, appointed saints---[may] favor [be] with you and peace from God our Father and [the] Lord Jesus Christ.

{for}: to

8 First, I thank my God through Jesus Christ for all of you, because your loyalty is celebrated in all the world. 9 Because my witness is God, whom I serve in my spirit in the gospel of his Son, how I unceasingly make a remembrance of you always in my prayers, 10 requesting if {now finally} somehow I will prosper in God’s will to come to you. 11 Because I want very much to see you, so that I can share some spiritual gift {with you, which would strengthen you;} 12 {that is,} to be encouraged together {among} you through the loyalty [that is] in each other, both yours and mine. 

{now finally}: ἤδη ποτὲ = now finally (BDAG)
{with you, which would strengthen you;}: to you to be strengthened
{that is,}: and this is
{among}: in

13 But I do not wish you to be unaware, brothers, that I often intended to come to you (and I was prevented up to now) so that I could have some fruit among you also, {just like}: just as also in the rest of the nations. 14 To both Greeks and barbarians, to both wise and foolish, I am a debtor. 15 Thus {my stated eagerness} to preach the gospel to you also who are in Rome. 

{just like}: just as also
{my stated eagerness}: the eagerness according to me

16 Because I am not ashamed of the gospel of Christ; because it is God's power to salvation to all who believe, both to [the] Jew first and to the Greek. 17 Because God's righteousness in {him} is revealed by loyalty, into loyalty, just as it is written, "But the righteous [one] will live by loyalty." 18 Because God's anger is revealed from heaven on all [the] ungodliness and unrighteousness of people who restrain the truth in unrighteousness; 19 because the knowledge of God is clear to them, because God made [it] clear to them. 20 Because his unseen [things] are clearly seen from [the] creation of the world, being understood through the things [he] made, both his eternal power and divinity, {so that they are} indefensible; 21 because, [while] knowing God, they did not glorify or thank [him] as God, but were made foolish in their reasoning, and their unwise heart was darkened. 

{him}: or, it
{so that they are}: in order for them to be

22 Claiming to be wise, they were made foolish, 23 and they exchanged the glory of [the] indestructible God {for} [the] resemblance of an image of destructible people and birds and four-footed [animals] and {snakes.} 24 Therefore God also gave them over in the desires of their hearts to uncleanness, of dishonoring their bodies among themselves; 25 whoever exchanged the truth of God for the lie, and revered and worshiped the creature above the creator, who is blessed into the ages. Amen. 

{for}: with
{snakes.}: or, reptiles

26 Because of this, God handed them over to dishonorable passions. Because their females exchanged the natural usage for what is against nature, 27 and similarly, the males also, abandoning the natural usage of females, burned in their lust toward each other, males committing the shameless deed with males, and receiving back in themselves the proper recompense of their delusion. 28 And just as they did not {see fit} to have God in [their] {consciousness,} God handed them over to a corrupt mind, to do what is improper,  29 having become filled with all unrighteousness, immorality, wickedness, avarice, evil; filled with envy, murder, discord, deceit, malevolence; gossips,  30 defamers, haters of God, insulters, boasters, inventors of evils, unyielding to parents, 31 ignorant, treacherous, unloving, implacable, unmerciful; 32 whoever, {knowing} God's precept, that those who practice such [things] are worthy of death, not only do the same, but also approve of those who do [these things]. 

{see fit}: BDAG
{consciousness,}: recognition
{knowing}: recognizing, same word as in 1:28

2:1 Therefore you are indefensible, O human, everyone who judges; because in what you judge another, you condemn yourself, because you who judge practice the same. 2 But we know that the judgment of God is {rightfully} against those who practice such [things]. 3 But do you think this, O human who judges those who practice such [things], and who do [the] same, that you will escape the judgment of God? 4 Or do you despise the wealth of his kindness and tolerance and patience, not knowing that the kindness of God is leading you to repentance? 5 But according to your obstinacy and unrepentant heart you store up for yourself anger on the day of anger and revelation and just judgment of God, 6 who will render to each according to his works; 7 to those who by steadfastness of good works seek glory and honor and immortality, eternal life, 8 but to those who are ambitious and disobey the truth but who obey unrighteousness, wrath and anger, 9 distress and anguish, on every human soul who does evil, to Jew first and to Greek; 10 but glory and honor and peace to all those who do the good, to Jew first and to Greek, 11 because there is no favoritism with God. 

{rightfully}: according to truth

12 Because as many as sinned without law will also die without law, and as many as sinned under [the] law will be judged through [the] law; 13 because [it is] not those who hear [the] law [who] are righteous with God, but those who do the law will be made righteous. 14 Because whenever Gentiles who do not have [the] law by nature do the [things] of the law, these, not having a law, are {a law} for themselves; 15 all those who display the work of the law written in their hearts, their conscience testifying with [them], and [their] thoughts among themselves accusing or even defending [them], 16 on the day when God judges the hidden [things] of humans, according to my gospel, by Jesus Christ. 

{a law}: In this section, up to here, the word translated “law,” except where accompanied with unitalicized “the,” has no article. Thus, only context determines whether it means “law,” “the law,” or “a law.”

17 Consider---you name [yourself] a Jew, and rely on the law, and boast in God, 18 and know [his] will, and approve the [things] that are excellent, being taught from the law, 19 and are confident {that you are} a guide of the blind, a light [for] those in darkness, 20 an instructor of [the] foolish, a teacher of [the] ignorant, having in the law the appearance of knowledge and truth; 21 therefore, you who teach someone else, do you not teach yourself? You who preach {against stealing,} do you steal? 22 You who {speak against committing adultery,} do you commit adultery? You who detest the idols, do you commit sacrilege? 23 [You] who boast in [the] law, do you dishonor God through {violating} the law? 24 Because the name of God is blasphemed in the nations because of you, just as it is written. 25 Because circumcision {does benefit,} if you practice [the] law; but if you are a violator of [the] law, your circumcision has become {uncircumcision.} 26 Therefore, if the uncircumcized [person] performs the righteousness of the law, will his uncircumcision not be counted {as} circumcision? 27 {And will the physically uncircumcized one who [still] fulfills the law [not] judge} you, who {having} {writings} and circumcision [are] a violator of [the] law? 28 {Because one who is outwardly a Jew is not [one], nor is it circumcision when outwardly [so], in [the] flesh,} 29 but one who is inwardly a Jew is [a Jew]---and circumcision [is] of heart, in Spirit, not {writings}---whose approval [is] not from humans, but from God.

{that you are}: to be
{against stealing,}: not to steal
{speak against committing adultery,}: say not to commit adultery
{violating}: the violation of
{does benefit,}: benefits
{uncircumcision.}: the word for uncircumcision or uncircumcized literally means foreskin
{as}: to
{And will the physically uncircumcized one who [still] fulfills the law [not] judge}: And will the by nature uncircumcized [person] fulfilling the law judge
{having}: Translates διὰ, or through, which is being used "of attendant or prevailing circumstance" (BDAG). Could be translated as with
{writings}: letter, Scripture
{Because one who is outwardly a Jew is not [one], nor is it circumcision when outwardly [so], in [the] flesh,}: Because not the one outwardly so is a Jew, nor [is] the outward in the flesh circumcision. "Outwardly" is something like "in the public"
{writings}: letter, Scripture

3:1 Therefore what [is] the advantage of the Jews, or what [is] the benefit of circumcision? 2 Much in every way---first, because they were entrusted [with] the revelations of God. 3 Because what if some were disloyal? Will {their} disloyalty nullify God's loyalty? 4 May it not be; instead, may God be true, but every human a liar, just as it is written,
/ "so that you may be vindicated in your word, 
/ and you will prevail {when you are judged."}
5 But if our unrighteousness proves God's righteousness, what will we say? Is God, who imposes the punishment, unrighteous? (I speak {like people.)} 6 May it not be; otherwise, how will God judge the world? 7 Because if God's truth {through} my lie overflowed into his glory, why am I still judged as a sinner?

{their}: his
{when you are judged."}: in your being judged
{like people.)}: according to man
{through}: in

[. . .]
<!--ἱλαστήριον = a place of mercy (note that this refers to the OT "mercy seat")--could also mean "votive offering," but less likely, since God is sending him.
-->

11:1
[. . .]
33 O [the] depth of God's wealth and wisdom and knowledge! How unsearchable [are] his judgments, and untraceable his ways. 34 Because who has known [the] mind of [the] Lord? Or who has become his counselor? 35 Or who has first given to him, and it will be given back to him? 36 Because from him and through him and to him are all [things]; to him be the glory into the ages. Amen.
[. . .]

# 1 Corinthians (1CO)

1:1 [test]
`;
let globalBible = defaultBible;
let writemode = false;

/*  The following declarations and functions are for the Bible Markdown reader engine.
    They convert Bible Markdown to HTML.
    Some of the code is reused from another Markdown engine.
    You will only need to call BMDtoHTML(), but the rest of the code is its dependencies. */

/* Copyright notice for Regex Markdown Parser, the regular markdown engine, which follows:

MIT License

Copyright (c) 2017 Angelos Chalaris

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

slightly edited by Lynn Michael Martin
*/

/***   Regex Markdown Parser by chalarangelo   ***/
// Replaces 'regex' with 'replacement' in 'str'
// Curry function, usage: replaceRegex(regexVar, replacementVar) (strVar)
const replaceRegex = function(regex, replacement){
    return function(str){
        return str.replace(regex, replacement);
    }
}
// Regular expressions for Markdown (a bit strict, but they work)
const codeBlockRegex = /((\n\t)(.*))+/g;
const inlineCodeRegex = /(`)(.*?)\1/g;
const imageRegex = /!\[([^\[]+)\]\(([^\)]+)\)/g;
const linkRegex = /\[([^\[]+)\]\(([^\)]+)\)/g;
const headingRegex = /\n(#+\s*)(.*)/g;
const boldItalicsRegex = /(\*{1,2})(.*?)\1/g;
const strikethroughRegex = /(\~\~)(.*?)\1/g;
const blockquoteRegex = /\n(&gt;|\>)(.*)/g;
const horizontalRuleRegex = /\n((\-{3,})|(={3,}))/g;
const unorderedListRegex = /(\n\s*(\-|\+)\s.*)+/g;
const orderedListRegex = /(\n\s*([0-9]+\.)\s.*)+/g;
//const paragraphRegex = /\n+(?!<pre>)(?!<h)(?!<ul>)(?!<blockquote)(?!<hr)(?!\t)([^\n]+)\n/g;
// Replacer functions for Markdown
const codeBlockReplacer = function(fullMatch){
    return '\n<pre>' + fullMatch + '</pre>';
}
const inlineCodeReplacer = function(fullMatch, tagStart, tagContents){
    return '<code>' + tagContents + '</code>';
}
const imageReplacer = function(fullMatch, tagTitle, tagURL){
    return '<img src="' + tagURL + '" alt="' + tagTitle + '" />';
}
const linkReplacer = function(fullMatch, tagTitle, tagURL){
    return '<a href="' + tagURL + '">' + tagTitle + '</a>';
}
const headingReplacer = function(fullMatch, tagStart, tagContents){
    return '\n<h' + tagStart.trim().length + '>' + tagContents + '</h' + tagStart.trim().length + '>';
}
const boldItalicsReplacer = function(fullMatch, tagStart, tagContents){
    return '<' + ( (tagStart.trim().length==1)?('em'):('strong') ) + '>'+ tagContents + '</' + ( (tagStart.trim().length==1)?('em'):('strong') ) + '>';
}
const strikethroughReplacer = function(fullMatch, tagStart, tagContents){
    return '<del>' + tagContents + '</del>';
}
const blockquoteReplacer = function(fullMatch, tagStart, tagContents){
    return '\n<blockquote>' + tagContents + '</blockquote>';
}
const horizontalRuleReplacer = function(fullMatch){
    return '\n<hr />';
}
const unorderedListReplacer = function(fullMatch){
    let items = '';
    fullMatch.trim().split('\n').forEach( item => { items += '<li>' + item.substring(2) + '</li>'; } );
    return '\n<ul>' + items + '</ul>';
}
const orderedListReplacer = function(fullMatch){
    let items = '';
    fullMatch.trim().split('\n').forEach( item => { items += '<li>' + item.substring(item.indexOf('.')+2) + '</li>'; } );
    return '\n<ol>' + items + '</ol>';
}
/*
const paragraphReplacer = function(fullMatch, tagContents){
    return '<p>' + tagContents + '</p>';
}
*/
// Rules for Markdown parsing (use in order of appearance for best results)
const replaceCodeBlocks = replaceRegex(codeBlockRegex, codeBlockReplacer);
const replaceInlineCodes = replaceRegex(inlineCodeRegex, inlineCodeReplacer);
const replaceImages = replaceRegex(imageRegex, imageReplacer);
const replaceLinks = replaceRegex(linkRegex, linkReplacer);
const replaceHeadings = replaceRegex(headingRegex, headingReplacer);
const replaceBoldItalics = replaceRegex(boldItalicsRegex, boldItalicsReplacer);
const replaceceStrikethrough = replaceRegex(strikethroughRegex, strikethroughReplacer);
const replaceBlockquotes = replaceRegex(blockquoteRegex, blockquoteReplacer);
const replaceHorizontalRules = replaceRegex(horizontalRuleRegex, horizontalRuleReplacer);
const replaceUnorderedLists = replaceRegex(unorderedListRegex, unorderedListReplacer);
const replaceOrderedLists = replaceRegex(orderedListRegex, orderedListReplacer);
//const replaceParagraphs = replaceRegex(paragraphRegex, paragraphReplacer);
// Fix for tab-indexed code blocks
const codeBlockFixRegex = /\n(<pre>)((\n|.)*)(<\/pre>)/g;
const codeBlockFixer = function(fullMatch, tagStart, tagContents, lastMatch, tagEnd){
    let lines = '';
    tagContents.split('\n').forEach( line => { lines += line.substring(1) + '\n'; } );
    return tagStart + lines + tagEnd;
}
const fixCodeBlocks = replaceRegex(codeBlockFixRegex, codeBlockFixer);
// Replacement rule order function for Markdown
// Do not use as-is, prefer parseMarkdown as seen below
const replaceMarkdown = function(str) {
return replaceOrderedLists(replaceUnorderedLists(
        replaceHorizontalRules(replaceBlockquotes(replaceceStrikethrough(
            replaceHeadings(replaceBoldItalics(replaceLinks(replaceImages(
                replaceInlineCodes(replaceCodeBlocks(str))
    ))))
    )))
    ));
}
// Parser for Markdown (fixes code, adds empty lines around for parsing)
// Usage: parseMarkdown(strVar)
const parseMarkdown = function(str) {
    return fixCodeBlocks(replaceMarkdown('\n' + str + '\n')).trim();
}
/* End code from Regex Markdown Parser */


/*  This function takes Bible Markdown, as well as code that has been pulled
    out of it, and translates it into HTML. You can simply put in the Markdown
    text, skipping the other arguments, or you can first run hidecode() and
    use its output .text, .quotes, and .code as the arguments for this function
    */
function BMDtoHTML(text, quotes = null, code = null) {
    // Make sure line breaks are formatted properly
    text = text.replace(/\r\n/g, "\n")
            .replace(/\u2028/g, "\n")
            .replace(/\u2029/g, "\n")
            .replace(/\n\n\n/g, "\n\n");

    // Format and remove metadata, to be returned later
    const possiblemeta = text.slice(0, text.search(/\n\n/));
    const metareg = /^(.*?): (.*)$/m;
    const metamatch = possiblemeta.match(metareg);
    let metadata = "";
    if (metamatch != null) {
        metadata = possiblemeta;
        const meta = /^(.*?): (.*)$/gm;
        metadata = metadata.replace(meta, (match, name, content) => {
            name = name.replace(/"/g, '&quot;');
            content = content.replace(/"/g, '&quot;');
            return `<meta name="${name}" content="${content}">`;
        });
        text = text.replace(possiblemeta, "");
    }
    
    // Make smart quotes
    text = text
    .replace(/( |\n|-|–|—|\u00A0)"/g, '$1“')
    .replace(/( |\n|-|–|—|\u00A0)'/g, '$1‘')
    .replace(/"/g, '”')
    .replace(/'/g, '’');

    // Get lots of the markdown with borrowed engine
    text = parseMarkdown(text);
    
    // Replace m and n dashes. This code must follow the code for 
    // turning ----- into horizontal rules or headings
    text = text.replace(/---/g, "&mdash;");
    text = text.replace(/--/g, "&ndash;");

    // Format additional text
    text = text.replace(/(?<!\\)\[([\s\S]*?)\]/g, '<span class="a">$1</span>');

    // Remove escape characters around brackets
    text = text.replace(/\\(\[|\])/g, "$1");

    // Format poetry using non-breaking spaces
    text = text.replace(/(\n|^)\/(\s+)(\S)/g, (match, newline, spaces, letter) => {
        let nbsp = "&nbsp;".repeat(spaces.length - 1);
        return newline + nbsp + " " + letter;
    });

    // Insert line breaks within paragraphs
    const br = /((?!\d>)(?!p>)(?!r>)\S)( *\n *(?!<h)(?!<p)(?!<b)(?!<m)\S)/g;
    text = text.replace(br, '$1<br/>$2');

    // Format verse numbers
    text = text.replace(/(<h1>)(\d+) ([\s\S]*?<\/h1>)/g, "$1$2\\ $3"); // Make sure titles like 1 Corinthians work
    text = text.replace(/(\s|>)(\d+) (\S)/g, '$1<sup class="v">$2&nbsp;</sup>$3');

    // Remove abbreviations in book names
    text = text.replace(/(<h1>.*) \(.*\)(.*<\/h1>)/g, "$1$2");

    // Format chapter numbers where they are starting a chapter
    text = text.replace(/(^|\s|>)(\d+):(1\s|\s)/g, '$1<span class="c">$2</span>');

    // Remove escape characters after numbers
    text = text.replace(/(\s|>|:)(\d+)\\/g, '$1$2');

    // Find the breaks between paragraphs
    text = ('\n\n' + text).replace(/(?:^|\n\n)([\s\S]*?)(?=\n\n|$)/g, '<p>$1</p>');

    // Restore metadata
    text = metadata + text;
    
    // Replace code that was removed for protection (if any)
    if (quotes != null || code != null) {
        text = replacecode(text, quotes, code);
    }

    return text;
}

// Change numbers to letters for footnotes: 1 = a, 2, = b, 27 = aa, 28 = ab
function numbertoletter(number) {
    let num = number;
    const b26 = [];
    for (let i = 0; i < num; i++) {
        if (number > 26) {
            b26.push(number % 26);
            number = Math.floor((number) / 26);
        } else {
            b26.push(number);
            break;
        }
    }
    b26.reverse();
    let letter = String.fromCharCode(96 + b26[0]);
    if (b26.length > 1) {
        for (let i = 1; i < b26.length; i++) {
            letter += String.fromCharCode(96 + b26[i]);
        }
    }
    return letter;
}

// Trim off punctuation for better-styled footnote text
function trimpunctuation(text) {
    let punctuation = new RegExp('[\\.,“”"\'‘’\\-–—\\(\\)]');
    for (let i = 0; i < text.length; i++) {
        if (punctuation.test(text[0])) {
            text = text.slice(1);
        } else {
            break;
        }
    }
   
    for (let i = 0; i < text.length; i++) {
        if (punctuation.test(text[text.length - 1])) {
            text = text.slice(0, text.length - 1);
        } else {
            break;
        }
    }
    
    return text;
}

// This removes any HTML code that is not using Markdown, to be replaced later
function hidecode(text) {

    const quotes = [];
    const code = [];

    // Remove content that's in comments or quotes (since they are equal)
    while (text.includes('"') || text.includes('<!--')) { //--> (this helps the editor not see errors)
        let openq = text.search(/"/);
        let openc = text.search(/<!--/); //-->

        if (openq == -1 && openc == -1) { // If they're both -1
            break;
        } else if ((openq > -1 && openq < openc) || openc == -1) {
            const firstslice = text.slice(0, openq);
            const nextslice = text.slice(openq + 1);

            let closeq = nextslice.search(/"/); // Or /(?<!\\)(?:\\\\)*"/ to be more proper?
            if (closeq > -1) {
                quotes.push('"' + nextslice.slice(0, closeq + 1));

                text = firstslice + `¡»${quotes.length - 1}«¡` + nextslice.slice(closeq + 1);
            } else {
                break;
            }
        } else {
            const firstslice = text.slice(0, openc);
            const nextslice = text.slice(openc + 4);

            let closec = nextslice.search(/-->/);
            if (closec > -1) {
                code.push('<!--' + nextslice.slice(0, closec + 3)); //-->

                text = firstslice + `¶»${code.length - 1}«¶` + nextslice.slice(closec + 3);
            } else {
                break;
            }
        }
    }

    // Remove content that is in script tags //
    text = text.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/g, codeblock => {
        code.push(codeblock);
        return `¶»${code.length - 1}«¶`;
    });

    // Remove content that is in style tags //
    text = text.replace(/<style[\s\S]*?>[\s\S]*?<\/style>/g, codeblock => {
        code.push(codeblock);
        return `¶»${code.length - 1}«¶`;
    });

    // Remove content that is in angle brackets //
    text = text.replace(/<[\s\S]*?>/g, codeblock => {
        code.push(codeblock);
        return `¶»${code.length - 1}«¶`;
    });

    // Remove content that is in & to ; tags //
    text = text.replace(/&\S+?;/g, codeblock => {
        code.push(codeblock);
        return `¶»${code.length - 1}«¶`;
    });

    // Replace content that is in quotes (this will have to be done again in replacecode())
    text = text.replace(/¡»(\d+)«¡/g, (match, index) => quotes[index] ?? match);

    return {"text": text, "quotes": quotes, "code": code};
}

// Replace code that has been removed for protection
function replacecode(text, quotes, code) {
    // Replace content that is in quotes
    text = text.replace(/¶»(\d+)«¶/g, (match, index) => code[index] ?? match);

    // Replace content that is in quotes
    text = text.replace(/¡»(\d+)«¡/g, (match, index) => quotes[index] ?? match);

    return text;
}

/*  The following functions are for finding and returning a passage in a Bible Markdown text.
    You will only need to call querypassage(), but the rest of the functions (except for parsereference()) are its dependencies.
    You can also use parsereference() to transform a human-written reference to the format that querypassage can take.
*/

/* this function takes the following arguments:
    text = the Bible Markdown text
    book = the three-letter code for the book
    - If left as "", this will return the whole Bible.
    startchapter = the starting chapter
    - If 0, it will include any front matter of the book.
    startverse = the starting verse
    - If 0, it will include any front matter of the chapter.
    endchapter = the chapter of the last verse to include
    - If -1, it will return the rest of the book, following the starting reference
    endverse = the last verse to include
    - If -1, it will return the rest of the chapter, following the starting reference
*/
function querypassage(text, book = "", startchapter = 0, startverse = 0, endchapter = -1, endverse = -1) {
    let error = false;
    book = book.toUpperCase();
    if (book != "") {
        const bookr = new RegExp('\\n# [\\s\\S]*? \\(' + book + '\\)');
        const booki = text.search(bookr);
        if (booki > -1) {
            // Start it at the book start
            text = text.slice(booki + 1);
            if (startchapter > 0) {
                const chapr = new RegExp('(\\s|>)' + startchapter + ':(\\d+|\\s)');
                const chapi = text.search(chapr);
                if (chapi > -1) {
                    // Start it at the chapter start
                    text = text.slice(chapi);

                    if (startverse > 0) {
                        let versi = 0;
                        if (text.search(new RegExp('(\\s|>)' + startchapter + ':' + startverse + ' (\\S)')) > -1) {
                            versi = text.search(new RegExp('(\\s|>)' + startchapter + ':' + startverse + ' (\\S)'));
                        } else if (startverse > 0) {
                            const versr = new RegExp('(\\s|>|:)' + startverse + ' (\\S)');
                            versi = text.search(versr);
                        }

                        if (versi > -1) {
                            // Start it at the verse start
                            text = text.slice(versi + 1);
                        
                        } else {
                            text = "No such verse."
                            error = true;
                        }
                    }
                } else {
                    text = "No such chapter."
                    error = true;
                }
            }
        } else {
            text = "No such book."
            error = true;
        }
        if (error == false) {
            // Now you need to pull out all the footnotes and add them
            let footnotes = findfootnotes(text);
            text = footnotes[0];
            footnotes = footnotes.slice(1);

            // End it at the book end
            text = slicetobookend(text);

            if (endchapter > -1) {
                // End it at start of next chapter
                for (let i = endchapter + 1; i < 152; i++) {
                    if (text.search(new RegExp('(\\s|>)' + i + ':(\\d+|\\s)')) > -1) {
                        text = text.slice(0, text.search(new RegExp('(\\s|>)' + (i) + ':(\\d+|\\s)')));
                        break;
                    }
                }
                if (endverse > -1) {
                    // End it at start of next verse
                    //text = text.slice(0, text.search(new RegExp('(\\s|>|:)' + (endverse + 1) + ' (\\S)')));
                    const findverse = new RegExp('(\\s|>|:)' + (endverse + 1) + ' (\\S)', 'g');
                    //AI
                    let lastIndex = -1;
                    let match;

                    while ((match = findverse.exec(text)) !== null) {
                        lastIndex = match.index; // position of current match
                    }

                    if (lastIndex !== -1) {
                        text = text.slice(0, lastIndex);
                    }
                    //end
                }
            }
            
            text = findreferences(text, footnotes);
        }
    } else {
        // Now you need to pull out all the footnotes and add them
        let footnotes = findfootnotes(text);
        text = footnotes[0];
        footnotes = footnotes.slice(1);

        // No ending of the text needed, since we're doing the whole text.

        text = findreferences(text, footnotes);
    }
    return text;
}

// Finds the end of the book and returns a sliced string
function slicetobookend(text) {
    return text.slice(0, text.search(/\n# ([^#\n]+?) \(([^)]+)\)/)); //
}

// Finds the footnotes in text and returns them in an array
function findfootnotes(text) {
    const footnotes = [];
    for (let i = 0; i < text.length; i++) {
        let match = text.match(/\n{([\s\S]*?)}: (.*)/);
        if (match) {
            text = text.replace(match[0], "");
            footnotes.push({"quote": match[1], "note": match[2]});
        } else {
            break;
        }
    }
    footnotes.unshift(text);
    return footnotes;
}

// Finds the references to specified footnotes in text and adds and formats them
function findreferences(text, footnotes) {
    let footnotetext = "";
    for (let i = 0; i < text.length; i++) {
        let match = text.match(/{([\s\S]*?)}/);
        if (match) {
            let footnote = footnotes.find(item => item.quote === match[1]);
            if (footnote != null) {
                let letter = numbertoletter(i + 1);
                footnotetext += '<p class="f"><a id="footnote-' + i +
                    '" href="#reference-' + i + '">\\[' + letter + '\\]</a>' + ' “' + 
                    trimpunctuation(footnote.quote) + '”&mdash;' + footnote.note + '</p>';
                text = text.replace(match[0], match[1] + '<a id="reference-' + i + 
                    '" href="#footnote-' + i + '"><sup>\\[' + letter + '\\]</sup></a>');
            }
        } else {
            break;
        }
    }
    if (footnotetext != "") {
        text += "<hr/>" + footnotetext;
    }
    return text;
}

// Parses a human-written bible reference. Example formats are "", "ROM", "ROM 3", "ROM 3:1", "ROM 3:1-3", "ROM 3:1-4:8" 
function parsereference(text) {
    text = text.trim();
    let book = "";
    let chap = 0;
    let vers = 0;
    let chap2 = -1;
    let vers2 = -1;
    if (text != "") {
        let books = text.split(" ");
        book = books[0];
        
        if (books[1]) {
            let chaps = books[1].split(":");
            chap = parseInt(chaps[0]);
            if (chaps[1]) {
                let chapsa = chaps[1].toString();
                if (chaps[2]) {
                    chapsa += ":" + chaps[2];
                }
                let verss = chapsa.split("-");
                vers = parseInt(verss[0]);
                if (verss[1]) {
                    chap2s = verss[1].split(":");
                    if (chap2s[1]) {
                        chap2 = parseInt(chap2s[0]);
                        vers2 = parseInt(chap2s[1]);
                    } else {
                        chap2 = chap;
                        vers2 = parseInt(chap2s[0]);
                    }
                } else {
                    chap2 = chap;
                    vers2 = vers;
                }
            } else {
                chap2 = chap;
            }
        }
    }
    return {"book": book, "startingchapter": chap, "startingverse": vers, "endingchapter": chap2, "endingverse": vers2};
}

/* The following functions are only to do with the reader/writer's UI */
// This is the code that pulls everything together to load the passage
function loadpassage(text) {
    const reference = parsereference(text);
    const freedtext = hidecode(globalBible);
    document.getElementById("reader").innerHTML = BMDtoHTML(querypassage(freedtext.text, reference.book, reference.startingchapter,
        reference.startingverse, reference.endingchapter, reference.endingverse), freedtext.quotes, freedtext.code);
}

// This switches between using the default Bible and one in the #writer textarea
function changesource(checked) {
    if (checked) {
        document.getElementById("writer").style.display = "none";
        writemode = false;
        globalBible = defaultBible;
        loadpassage(document.getElementById('passage').value);
    } else {
        document.getElementById("writer").style.display = "flex";
        writemode = true;
        globalBible = document.getElementById("writer").value;
        loadpassage(document.getElementById('passage').value);
    }
}

// This updates the #reader whenever the code in the #writer textarea is changed
function updatereader() {
    if (writemode) {
        globalBible = document.getElementById("writer").value;
        loadpassage(document.getElementById('passage').value);
    }
}
</script>

<style>
/* Remove underlining in links */
a {
    text-decoration: none;
}
/* Chapter number formatting */
.c {
    border: 0.5px solid black;
    font-weight: 700;
    padding: 0 5px;
}
/* Verse number formatting */
.v {
    font-weight: bold;
}
/* Footnote letter formatting */
.f {
    font-size: 0.75em;
}
/* Make superscript not change line height */
sup {
    line-height: 0;
}
/* Additional text formatting */
.a {
    text-decoration: underline;
    text-decoration-style: dotted;
}

/* Specific to this app */
@font-face {
  font-family: 'Commit Mono';
  src: url(/Commit/CommitMono-400-Regular.otf);
}
body {
    font-family: 'Cardo', 'Times New Roman', Times, serif;
    background: #222226;
}
#main {
    display: flex;
    flex-direction: column;
    height: 80vh;
}
.reader, .writer {
    background: white;
    padding: 50px;
    border-radius: 10px;
    max-width: 600px;
}
.writer {
    resize: none;
    font-family: 'Commit Mono', 'Ubuntu Mono', 'Consolas', monospace;
    font-size: 10pt;
    display: none;
    line-height: 1.5;
}
.reader {
    line-height: 1.5;
}
#reader, #writer {
    width: 50%;
    height: 100%;
}
#view {
    display: flex;
    justify-content: center;
    align-items: stretch;
    flex: 1;
    gap: 20px;
}
#controls {
    margin: 20px auto;
    text-align: center;
}
label {
    color: white;
}
</style>
</head>
<body>

<div id="main">
    <div id="controls">
        <input type="text" id="passage"/>
        <button onclick="loadpassage(document.getElementById('passage').value)">Search</button>
        <input type="checkbox" id="source" checked="true" onchange="changesource(this.checked)"/>
        <label for="source">Default Bible</label>
    </div>
    <div id="view">
        <textarea id="writer" class="writer" oninput="updatereader()"></textarea>
        <div class="reader" id="reader"></div>
    </div>
</div>
<script>
    changesource(document.getElementById("source").checked);
</script>

</body>
</html>